#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     lightRear,      sensorLightActive)
#pragma config(Sensor, S3,     lightLeft,      sensorLightActive)
#pragma config(Sensor, S4,     lightRight,     sensorLightActive)
#pragma config(Motor,  motorA,          pushButton,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightTrack,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          leftTrack,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int trippedLight = -1; // 1 = lightLeft, 2 = lightRight, 3 = lightRear
int threshL =0, threshR =0, threshB=0;
bool liftUp = true;

int lightsClear(){
	// if first cycle, set thresholds for individual lights
	if(threshL == 0){
		threshL = SensorValue(lightLeft);
		threshR = SensorValue(lightRight);
		threshB = SensorValue(lightRear);
	}
	//check for lights tripped
	if(SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5){
		trippedLight = 1; //light Left tripped, this val sent to lightsTripped()
		return 0;
	}
	if(SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5){
		trippedLight = 2; //light Right tripped, this val sent to lightsTripped()
		return 0;
	}
	if(SensorValue(lightRear) < threshB - 5 || SensorValue(lightRear) > threshB + 5){
		trippedLight = 3; //light left tripped, this val sent to lightsTripped()
		return 0;
	}else return 1;
}

void lightTripped(){ 
	// light sensor has been tripped
	if(trippedLight == 1){
		// Left light tripped, Reverse robot to the right
		nMotorEncoder[motorB] = 0;
		nSyncedMotors = synchBC;
		nSyncedTurnRatio = 50;
		//checks other lights while reversing to right
		while(nMotorEncoder[motorB] < -507.5 && lightsClear()) { //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			
			//if!((SensorValue(lightRear) < threshB - 5 || SensorValue(lightRear) > threshB + 5) || (SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5)) motor[motorB] = 50;
			motor[motorB] = 50;			
		}
		motor[motorB] = 0;
	
	}else if(trippedLight == 2){
		// Right light is tripped
		//reverse robot to the left
		nMotorEncoder[motorC] = 0;
		nSyncedMotors = synchBC;
		nSyncedTurnRatio = 50;
		//check other lights while reversing
		while(nMotorEncoder[motorC] < -507.5 && lightsClear()){ //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			
			//if!((SensorValue(lightRear) < threshB - 5 || SensorValue(lightRear) > threshB + 5) || (SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5)) motor[motorC] = 50;
			motor[motorC] = 50;
		}
	}else if(trippedLight == 3){
		//rear light tripped, forward 45 deg to left
		nMotorEncoder[motorB] = 0;
		nSyncedMotors = synchBC;
		nSyncedTurnRatio = -50;
		//check other lights while moving forward at angle
		while(nMotorEncoder[motorB] < 507.5 && lightsClear()) { //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			
			//if!((SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5) || (SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5)) motor[motorB] = 50; 
			motor[motorB] = 50; 
			
		}
		motor[motorB] = 0;
	}
}

void triggerLift(){
	nMotorEncoder[pushButton] = 0;
	while(nMotorEncoder[pushButton] < 355) motor[pushButton] = 100;
	motor[pushButton] = 0;
}

void customBack(int distance, int speed){
	nMotorEncoder[motorB] = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
	while(nMotorEncoder[motorB] > (distance * -34) && lightsClear()) {
		motor[motorB] = -1*(speed);
	}
	motor[motorB] = 0;
}

void customFwd(int distance, int speed){
	nMotorEncoder[motorB] = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
	while(nMotorEncoder[motorB] < (distance * 34) && lightsClear()) {

		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/

		motor[motorB] = speed;
	}
	motor[motorB] = 0;
}

void customL(int degree){
	nMotorEncoder[motorB] = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	while(nMotorEncoder[motorB] < degree * 6 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			
			break;
		}
		*/
		motor[motorB] = 50; 
	}
	motor[motorB] = 0;
}
void customR(int degree){
	nMotorEncoder[motorC] = 0;
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = -100;
	while(nMotorEncoder[motorC] < degree * 6 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorC] = 50;
	}
	motor[motorC] = 0;
}

void forwardInch(){
	nMotorEncoder[motorB] = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
	while(nMotorEncoder[motorB] < 87 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorB] = 95;
	}
	motor[motorB] = 0;
}

void reverseInch(){
	nMotorEncoder[motorB] = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;

	while(nMotorEncoder[motorB] > -87 && lightsClear()) {
		motor[motorB] = -95;
	}
	motor[motorB] = 0;
}

void turn90L(){//Left
	nMotorEncoder[motorB] = 0;
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	while(nMotorEncoder[motorB] < 507.5 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			
			break;
		}
		*/
		motor[motorB] = 50; 
	}
	motor[motorB] = 0;
}

void turn90R(){
	nMotorEncoder[motorC] = 0;
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = -100;
	while(nMotorEncoder[motorC] < 507.5 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorC] = 50;
	}
	motor[motorC] = 0;
}

void turn180R(){//Right
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] < 1015 && lightsClear()) {
		motor[motorC] = 100;
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
	}
	motor[motorC] = 0;
}

void turn180L(){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < 1015) {
		/*if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorB] = 100;
	}
	motor[motorB] = 0;
}

task main()
{

	while(1){
		
		while(lightsClear()){
			scanForWall();
			/*
				switch(state){
					case 0: scanForWall(state); //find wall, put back to it
					break;
					case 1: scanningState(state); //with back to wall, then search for targets and attack
					break;
					case 2: resetState(state); //scan 360 and keep distance
					break;
				}
			*/
			forwardInch();
		}
		// light has been tripped
		lightTripped();
	}	
}
void scanForWall(int state){
	int distance1, distance2;
	
	while(lightsClear()){
		//checking for wall, first point of data
		forwardInch();

		
		if(SensorValue(sonar) <= 35) {
			//when seeing wall for first time, reverse for a short bit then rotate 90, move a bit, rotate 90 back and check for wall again
			while(lightsClear()){
				reverseInch();
				reverseInch();
				distance1 = SensorValue(sonar); //save distance to supposed wall
				//spin 90 deg
				turn90R();
				//move forward parallel to supposed wall
				forwardInch();
				forwardInch();
				forwardInch();
			    //rotate 90 back to face wall and check distance
				turn90L();
				distance2 = SensorValue(sonar); //save second distance var to check against distance1
				//calculate to determine if obj is wall
				if(distance1 - distance2 < 4 && distance1 - distance2 > -4){
					//we are facing a wall, spin 180
					while(lightsClear()){
						turn180L();
						state++;
						return; //increases switch state and returns
					}
				}
			} //end while loop
			lightTripped();
		}//end if statement
		state++; //goes to scanning state
		
	}//end first while loop
	
	lightTripped();
	
}//end turtle state