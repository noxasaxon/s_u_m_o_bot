#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     lightRight,      sensorLightActive)
#pragma config(Sensor, S3,     lightLeft,      sensorLightActive)
#pragma config(Sensor, S4,     lightRear,     sensorLightActive)
#pragma config(Motor,  motorA,          pushButton,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightTrack,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          leftTrack,     tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int state = 1; //1 = put back to wall, 2 = lookForTarget, 3 = Attack
int trippedLight = -1; // 1 = lightLeft, 2 = lightRear, 3 = lightRight
int threshL =0, threshR =0, threshB=0;
bool liftUp = true;
bool target_acquired = false;

void lightTripped();
void turn180L();
void turn180R();
void turn90L();
void turn90R();
void customBack();
void customFwd();
void customL();
void customR();

int lightsClear(){
	// if first cycle, set thresholds for individual lights
	if(threshL == 0){
		threshL = SensorValue(lightLeft);
		threshR = SensorValue(lightRight);
		threshB = SensorValue(lightRear);
	}
	//check for lights tripped

	if(SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5 && trippedLight != 1){
		trippedLight = 1; //light Left tripped, this val sent to lightsTripped()
		lightTripped();
        return 0;
	}
    if(SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5 && trippedLight != 3){
		trippedLight = 2; //light Rear tripped, this val sent to lightsTripped()
		lightTripped();
        return 0;
    }
    if(SensorValue(lightRear) < threshB - 9 || SensorValue(lightRear) > threshB + 9 && trippedLight != 2 ){
		trippedLight = 3; //light left tripped, this val sent to lightsTripped()
        lightTripped();
		return 0;
	}else return 1;
}

void lightTripped(){
	// light sensor has been tripped

    if(trippedLight == 1){
        playSoundFile("HornSiren.RSO");
		// Left light tripped, Reverse robot to the right
		nSyncedMotors = synchBC;
		nSyncedTurnRatio = 100;
		nMotorEncoder[motorB] = 0;
		//checks other lights while reversing to right
		while(nMotorEncoder[motorB] > -250){ //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			if(!((SensorValue(lightRear) < threshB - 5 || SensorValue(lightRear) > threshB + 5) || (SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5))){
                motor[motorB] = -50;
            }
		}
        motor[motorB] = 0;
        //turn L 90
        nSyncedTurnRatio = -100;
        nMotorEncoder[motorB] = 0;
        while(nMotorEncoder[motorB] < 507.5){ //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			if(!((SensorValue(lightRear) < threshB - 5 || SensorValue(lightRear) > threshB + 5) || (SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5))){
                motor[motorB] = 50;
            }
		}
		motor[motorB] = 0;

	}else if(trippedLight == 2){
		// Right light is tripped
		//reverse robot to the left
        playSoundFile("HornSiren.RSO");
		nSyncedMotors = synchBC;
		nSyncedTurnRatio = 100;
		nMotorEncoder[motorB] = 0;
		//checks other lights while reversing to right
		while(nMotorEncoder[motorB] > -250){ //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			if(!((SensorValue(lightRear) < threshB - 9 || SensorValue(lightRear) > threshB + 9) || (SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5))){
			motor[motorB] = -50;
            }
		}
        motor[motorB] = 0;
        //turn L 90
        nSyncedTurnRatio = -100;
        nMotorEncoder[motorB] = 0;
        while(nMotorEncoder[motorB] < 507.5){
            if(!((SensorValue(lightRear) < threshB - 9 || SensorValue(lightRear) > threshB + 9) || (SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5))){
			    motor[motorB] = 50;
            }
		}
        motor[motorB] = 0;

	}else if(trippedLight == 3){
        playSoundFile("HornSiren.RSO");
		//rear light tripped, forward 45 deg to left
		nSyncedMotors = synchBC;
		nSyncedTurnRatio = 100;
		nMotorEncoder[motorB] = 0;
		//checks other lights while reversing to right
		while(nMotorEncoder[motorB] < 260){ //if this doesnt work, remove lightsClear and use the commented out code below to begin fixing
			if(!((SensorValue(lightRight) < threshR - 5 || SensorValue(lightRight) > threshR + 5) || (SensorValue(lightLeft) < threshL - 5 || SensorValue(lightLeft) > threshL + 5))){
			    motor[motorB] = 50;
            }

		}
		motor[motorB] = 0;
	}
    trippedLight = -1; //reset trip light
}

void triggerLift(){
	nMotorEncoder[pushButton] = 0;
	while(nMotorEncoder[pushButton] < 355) motor[pushButton] = 100;
	motor[pushButton] = 0;
}

void customBack(int distance, int speed){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
    nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] > (distance * -34) && lightsClear()) {
		motor[motorB] = -1*(speed);
	}
	motor[motorB] = 0;
}

void customFwd(int distance, int speed){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
    nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < (distance * 34) && lightsClear()) {

		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/

		motor[motorB] = speed;
	}
	motor[motorB] = 0;
}

void customL(int degree){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < degree * 5.6 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {

			break;
		}
		*/
		motor[motorB] = 50;
	}
	motor[motorB] = 0;
}
void customR(int degree){
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] < degree * 5.6 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorC] = 50;
	}
	motor[motorC] = 0;
}

void forwardCm(){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
    nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < 34 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/

		motor[motorB] = 95;

	}
	motor[motorB] = 0;
}

void forwardInch(){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < 87 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorB] = 95;
	}
	motor[motorB] = 0;
}

void reverseInch(){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = 100;
    nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] > -87 && lightsClear()) {
		motor[motorB] = -95;
	}
	motor[motorB] = 0;
}

void turn90L(){//Left
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
    nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < 507.5 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {

			break;
		}
		*/
		motor[motorB] = 50;
	}
	motor[motorB] = 0;
}

void turn90R(){
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = -100;
    nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] < 507.5 && lightsClear()) {
		//for scanning physical objects while moving
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorC] = 50;
	}
	motor[motorC] = 0;
}

void turn180R(){//Right
	nSyncedMotors = synchCB;
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] < 1015 && lightsClear()) {
		motor[motorC] = 100;
		/*
		if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
	}
	motor[motorC] = 0;
}

void turn180L(){
	nSyncedMotors = synchBC;
	nSyncedTurnRatio = -100;
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < 1015) {
		/*if (SensorValue(sonar) < 20) {
			target_acquired = true;
			break;
		}
		*/
		motor[motorB] = 100;
	}
	motor[motorB] = 0;
}

task main()
{
	nVolume = 4;
	while(1){
		while(lightsClear()){
			/*	switch(state){
					case 0: scanForWall(state); //find wall, put back to it
					break;
					case 1: lookForTarget(state); //with back to wall, then search for targets and attack
					break;
					case 2: attackState(state); //scan 360 and keep distance
					break;
				} */

			lookForTarget();

		}
		// light has been tripped
	}
}
void scanForWall(int state){
	int distance1, distance2;

	while(lightsClear()){
		//checking for wall, first point of data
		forwardCm();
		if(SensorValue(sonar) <= 35) {
			//when seeing wall for first time, reverse for a short bit then rotate 90, move a bit, rotate 90 back and check for wall again
			while(lightsClear()){
				reverseInch();
				reverseInch();
				distance1 = SensorValue(sonar); //save distance to supposed wall
				//spin 90 deg
				turn90R();
				//move forward parallel to supposed wall
				forwardInch();
				forwardInch();
				forwardInch();
			    //rotate 90 back to face wall and check distance
				turn90L();
				distance2 = SensorValue(sonar); //save second distance var to check against distance1
				//calculate to determine if obj is wall
				if(distance1 - distance2 < 4 && distance1 - distance2 > -4){
					//we are facing a wall, spin 180
					while(lightsClear()){
						turn180L();
						state++;
						return; //exit LookForWall go to next state
					}
				}
				else{
					// Wall not found at second check, original object was enemy
					//navigate quickly back to object and initiate attack state
					while(lightsClear()){
						customL(50);
						forwardInch();
						forwardInch();
						state++; //skip look for target state
						state++; //go to attack state
						return;
					}
				}
			} //end while loop
		}//end if statement
	}//end first while loop
}

void lookForTarget(){
	//patrol play field, looking for target
	while(lightsClear()){
		if(SensorValue(sonar) < 20){
			if(target_acquired == false) triggerLift();
			target_acquired = true;
			forwardCm();
			//state++;//target found, initiate attack state
		}else{
			if(target_acquired == true) {
				target_acquired = false;
				triggerLift();
			}
			forwardCm();
			customL(30);
		}
	}
}
